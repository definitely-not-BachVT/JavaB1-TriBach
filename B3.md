# Buổi 3: Mọi thứ đều là đối tượng

## Tính đóng gói

Tính đóng gói **(Encapsulation)** trong Java là một trong bốn nguyên tắc cơ bản của lập trình hướng đối tượng (OOP).

Nói một cách đơn giản, đóng gói là kỹ thuật che giấu thông tin **(data hiding)** bằng cách gói gọn dữ liệu **(các biến)** và các phương thức **(hàm)** xử lý dữ liệu đó vào bên trong một lớp **(class)**. Lớp đó sẽ kiểm soát quyền truy cập vào dữ liệu của nó từ bên ngoài.

-----

### Cách thức hoạt động

Việc triển khai đóng gói trong Java tuân theo các bước sau:

1.  **Khai báo `private`:**

      * Tất cả các biến (thuộc tính) của lớp được khai báo là `private`.
      * Điều này ngăn chặn các lớp khác truy cập trực tiếp vào chúng.

2.  **Cung cấp public methods:**

      * Lớp cung cấp các phương thức `public` để truy cập và thay đổi giá trị của các biến `private` đó. Các phương thức này thường được gọi là:
          * **Getter:** Phương thức dùng để lấy (get) giá trị của một biến. (ví dụ: `getTen()`)
          * **Setter:** Phương thức dùng để thiết lập (set) giá trị cho một biến. (ví dụ: `setTen(String tenMoi)`)

-----

### Ví dụ minh họa

Xét một lớp `XeHoi` (Car) đơn giản. Chúng ta không muốn ai cũng có thể thay đổi tốc độ (speed) của xe một cách tùy tiện (ví dụ: gán tốc độ âm).

```java
public class XeHoi {
    // 1. Dữ liệu được che giấu (private)
    private int tocDo;
    private String tenModel;

    // 2. Phương thức public (Getter) để đọc dữ liệu
    public int getTocDo() {
        return this.tocDo;
    }

    // 2. Phương thức public (Setter) để thay đổi dữ liệu
    public void setTocDo(int tocDoMoi) {
        // Lớp có thể kiểm soát dữ liệu đầu vào
        if (tocDoMoi >= 0) {
            this.tocDo = tocDoMoi;
        } else {
            System.out.println("Toc do khong the la so am!");
        }
    }
    
    // Getter và Setter cho tenModel
    public String getTenModel() {
        return this.tenModel;
    }

    public void setTenModel(String tenModel) {
        this.tenModel = tenModel;
    }
}
```

**Cách sử dụng:**

```java
// Trong một lớp khác
XeHoi vinfast = new XeHoi();

// KHÔNG THỂ truy cập trực tiếp (gây lỗi)
// vinfast.tocDo = -50; 

// PHẢI dùng phương thức Setter
vinfast.setTocDo(60);      // Hợp lệ
vinfast.setTocDo(-50);     // Không hợp lệ, sẽ in ra thông báo lỗi

// Dùng Getter để đọc giá trị
System.out.println(vinfast.getTocDo()); // In ra: 60
```

-----

### Lợi ích của tính đóng gói

  * **Kiểm soát dữ liệu:** Đây là lợi ích lớn nhất. Lớp có thể toàn quyền kiểm soát giá trị của các thuộc tính của nó. Như ví dụ trên, phương thức `setTocDo` đảm bảo tốc độ không bao giờ là số âm.
  * **Bảo mật (Data Hiding):** Các chi tiết triển khai bên trong của lớp được che giấu. Các lớp khác không cần biết cách thức lớp đó lưu trữ dữ liệu, chúng chỉ cần gọi các phương thức `public` được cung cấp.
  * **Tính linh hoạt và bảo trì:** Có thể thay đổi cách triển khai bên trong của lớp (ví dụ: đổi tên biến `tocDo` thành `vanTocHienTai`) mà không làm ảnh hưởng đến các lớp khác đang sử dụng nó, miễn là giữ nguyên các phương thức `public` (Getter/Setter).
  * **Dễ kiểm thử (Testability):** Giúp việc viết Unit Test dễ dàng hơn vì chỉ cần kiểm tra các phương thức `public`.

> **Unit test (hay Kiểm thử đơn vị)** là một phương pháp kiểm thử phần mềm tập trung vào việc kiểm tra các thành phần (unit) nhỏ nhất, độc lập của một chương trình. Một đơn vị có thể là một hàm hoặc một phương thức có trong class.

-----

## Tính kế thừa

Tính kế thừa (Inheritance) là trụ cột tiếp theo của lập trình hướng đối tượng (OOP) trong Java. Nó cho phép một lớp (gọi là **lớp con** - subclass) thừa hưởng các thuộc tính (biến) và phương thức (hàm) từ một lớp khác (gọi là **lớp cha** - superclass).

Từ khóa để thực hiện kế thừa trong Java là `extends`.

Mục đích chính: **Tái sử dụng mã (code reusability)** và tạo ra một mối quan hệ **IS-A (Relationship)**.

  * Ví dụ: `class Dog extends Animal {}`. Ở đây, `Dog` là lớp con, `Animal` là lớp cha.

### 1\. Đặc điểm chung

  * **Tái sử dụng:** Lớp con không cần phải viết lại các thuộc tính và phương thức đã có ở lớp cha. Nó có thể sử dụng lại chúng.
  * **Những gì được kế thừa:**
      * Các thành viên `public` và `protected` của lớp cha.
      * Các thành viên `default` (package-private) chỉ được kế thừa nếu lớp con nằm cùng package với lớp cha.
  * **Những gì KHÔNG được kế thừa:**
      * Các thành viên `private` của lớp cha. (Lớp con có chúng, nhưng không thể truy cập trực tiếp).
      * **Constructor** của lớp cha (đây là điểm quan trọng).
  * **Từ khóa `final`:**
      * Nếu một lớp được khai báo là `final`, nó không thể có lớp con (không thể bị kế thừa).
      * Nếu một phương thức được khai báo là `final`, nó không thể bị ghi đè (override) bởi lớp con.

### 2\. Constructor và Kế thừa

Đây là một khái niệm rất quan trọng và thường gây nhầm lẫn.

  * **Quy tắc:** Constructor không được kế thừa.
  * **Cách hoạt động:** Khi tạo một đối tượng của lớp con, constructor của lớp con luôn luôn phải gọi một constructor của lớp cha.
  * **Từ khóa `super()`:** Đây là cách để gọi constructor của lớp cha. Lệnh `super()` phải là câu lệnh đầu tiên trong constructor của lớp con.
  * **Gọi ngầm định (Implicit):** Nếu không viết `super()` trong constructor của lớp con, Java sẽ tự động thêm một lệnh `super();` (gọi constructor không tham số của lớp cha) vào dòng đầu tiên.
  * **Vấn đề:** Nếu lớp cha **không có** constructor không tham số (ví dụ: nó chỉ có constructor yêu cầu tham số), thì code sẽ bị lỗi biên dịch. Bắt buộc phải gọi `super(thamSo...)` một cách tường minh.

**Ví dụ:**

```java
class Animal {
    String name;

    // Constructor của lớp cha (có tham số)
    public Animal(String name) {
        this.name = name;
        System.out.println("Constructor Animal chay...");
    }
}

class Dog extends Animal {
    String breed;

    public Dog(String name, String breed) {
        // 1. PHẢI gọi super() và phải là dòng đầu tiên
        // Nếu không có dòng này, code sẽ lỗi vì Animal không có constructor mặc định
        super(name); // Gọi đến 'public Animal(String name)'
        
        System.out.println("Constructor Dog chay...");
        this.breed = breed;
    }
}

// Khi chạy: new Dog("Buddy", "Golden");
// Output sẽ là:
// Constructor Animal chay...
// Constructor Dog chay...
```

### 3\. Variable Hiding (Che giấu biến)

Đây là hiện tượng xảy ra khi lớp con khai báo một biến có tên trùng với một biến đã có ở lớp cha.

  * Đây **KHÔNG** phải là ghi đè (Overriding). Ghi đè chỉ áp dụng cho phương thức.
  * Khi điều này xảy ra, biến ở lớp con sẽ "che" (hide) biến ở lớp cha.
  * Việc truy cập biến nào sẽ được quyết định tại **thời điểm biên dịch (compile-time)**, dựa trên **kiểu tham chiếu** của đối tượng, chứ không phải kiểu đối tượng thực tế.

**Ví dụ:**

```java
class Parent {
    String message = "Day la Parent"; // Biến của cha
}

class Child extends Parent {
    String message = "Day la Child";  // Biến của con (che giấu biến cha)

    public void printMessages() {
        System.out.println(message);       // In ra: Day la Child
        System.out.println(super.message); // In ra: Day la Parent (dùng super để truy cập)
    }
}

// Rắc rối xảy ra ở đây (Đa hình)
Parent p = new Child();
System.out.println(p.message); // In ra: "Day la Parent"

// Lý do: 'p' có kiểu tham chiếu là Parent, nên nó truy cập 'message' của Parent.
// Điều này KHÁC HOÀN TOÀN với ghi đè phương thức (sẽ gọi của Child).
```

**Khuyến cáo:** Nên tránh việc che giấu biến vì nó làm code rất khó hiểu.

### 4\. Đa kế thừa (Multiple Inheritance)

  * **Câu trả lời ngắn:** Java **KHÔNG** hỗ trợ đa kế thừa lớp.
      * Một lớp con chỉ có thể `extends` (kế thừa) từ **một** lớp cha duy nhất.
  * **Tại sao?** Để tránh **"Vấn đề Kim cương" (Diamond Problem)**.
      * Tưởng tượng Lớp A có một phương thức `m()`.
      * Lớp B và C cùng kế thừa từ A và cả hai đều ghi đè (override) phương thức `m()`.
      * Nếu Java cho phép lớp D kế thừa từ cả B và C, thì khi D gọi `m()`, nó nên chạy phiên bản của B hay của C? Rất mơ hồ.
  * **Giải pháp của Java:** Sử dụng **Interfaces**.
      * Một lớp có thể `implements` (triển khai) **nhiều** interface.
      * Interface chỉ định nghĩa các hành vi (phương thức trừu tượng) mà lớp đó phải cung cấp.
      * `class MyClass extends SingleParent implements Interface1, Interface2, Interface3 {}`
      * Kể từ Java 8, interface có thể có `default methods` (phương thức có thân hàm). Điều này hơi giống đa kế thừa, nhưng Java có các quy tắc rõ ràng để giải quyết xung đột (nếu lớp cha đã implement thì sẽ ưu tiên lớp cha).

### 5\. Các khái niệm liên quan khác

  * **Method Overriding (Ghi đè phương thức):** Đây mới là sức mạnh thực sự của kế thừa, là nền tảng cho Tính đa hình (Polymorphism).
      * Lớp con cung cấp một định nghĩa khác cho một phương thức đã có ở lớp cha.
      * Điều kiện: Tên phương thức, kiểu trả về, và danh sách tham số phải giống hệt (hoặc tương thích).
      * Annotation `@Override` thường được dùng để báo cho trình biên dịch kiểm tra xem việc ghi đè có hợp lệ không.
  * **Các loại kế thừa (Types of Inheritance):**
      * **Đơn kế thừa (Single):** A -\> B (Java hỗ trợ)
      * **Đa cấp (Multilevel):** A -\> B -\> C (Java hỗ trợ)
      * **Phân cấp (Hierarchical):** A -\> B, A -\> C (Java hỗ trợ)
      * **Đa kế thừa (Multiple):** A -\> C, B -\> C (Java **KHÔNG** hỗ trợ qua `class`, nhưng hỗ trợ qua `interface`)

-----

## Upcasting và Downcasting

Upcasting và Downcasting là hai khái niệm cốt lõi trong tính đa hình (Polymorphism) của Java, liên quan đến việc ép kiểu giữa lớp cha và lớp con.

Trong đó:

  * **Upcasting:** Ép kiểu từ **lớp con** lên **lớp cha**.
  * **Downcasting:** Ép kiểu từ **lớp cha** xuống **lớp con**.

**Ví dụ:**

```java
// Lớp cha (Superclass)
class Animal {
    void eat() {
        System.out.println("Động vật đang ăn...");
    }
}

// Lớp con (Subclass)
class Dog extends Animal {
    @Override
    void eat() {
        System.out.println("Chó đang gặm xương...");
    }
    
    void bark() {
        System.out.println("Gâu gâu!");
    }
}
```

### 1\. Upcasting (Ép kiểu ngầm định)

Upcasting là hành động tham chiếu đến một đối tượng của lớp con bằng một tham chiếu của kiểu lớp cha.

  * **Đặc điểm:**
      * **An toàn:** Vì lớp con (`Dog`) luôn *là một* (is-a) phiên bản của lớp cha (`Animal`). Một con chó chắc chắn là một động vật.
      * **Thường là ngầm định:** Không cần phải viết code ép kiểu một cách tường minh vì Java tự động làm điều này.
      * **Giới hạn truy cập:** Khi đã upcast, chỉ có thể gọi các phương thức và truy cập các thuộc tính được định nghĩa trong lớp cha (`Animal`).
  * **Ví dụ:**
    ```java
    // Tạo đối tượng Dog
    Dog dog = new Dog();

    // Upcasting ngầm định (tự động)
    Animal animal = dog; 

    // Cũng có thể viết tường minh, nhưng không cần thiết:
    // Animal animal = (Animal) new Dog();

    // Có thể gọi phương thức của Animal
    animal.eat(); // Sẽ in ra: "Chó đang gặm xương..." (do tính đa hình)

    // KHÔNG THỂ GỌI phương thức của Dog
    // animal.bark(); // Lỗi biên dịch (Compile Error)
    ```
  * **Tại sao dùng?** Upcasting là nền tảng của tính đa hình. Nó cho phép viết code linh hoạt hơn. Ví dụ, có thể tạo một danh sách `List<Animal>` và thêm vào đó cả `Dog`, `Cat`, `Bird`, v.v.

### 2\. Downcasting (Ép kiểu tường minh)

Downcasting là hành động ép kiểu một tham chiếu từ lớp cha về lại kiểu của lớp con.

  * **Đặc điểm:**
      * **Không phải lúc nào cũng an toàn:** Một `Animal` chưa chắc đã là một `Dog` (nó có thể là `Cat`).
      * **Phải tường minh:** Bắt buộc phải sử dụng cú pháp ép kiểu `(KiểuLớpCon)`.
      * **Nguy cơ lỗi:** Nếu cố gắng downcast một đối tượng không phải là kiểu mong muốn, chương trình sẽ ném ra `ClassCastException` lúc chạy (runtime).
      * **Mở rộng truy cập:** Nếu thành công, sẽ lấy lại được quyền truy cập vào các phương thức và thuộc tính riêng của lớp con (`Dog`).
  * **Ví dụ:**
    ```java
    // Giả sử chúng ta có một 'animal' đang tham chiếu đến một 'Dog' (từ ví dụ upcasting)
    Animal animal = new Dog();

    // Downcasting tường minh
    Dog dog = (Dog) animal;

    // Bây giờ có thể gọi tất cả các phương thức
    dog.eat();  // "Chó đang gặm xương..."
    dog.bark(); // "Gâu gâu!" (Thành công!)
    ```

### Cách Downcast an toàn: Dùng `instanceof`

Vì Downcasting có thể gây lỗi, nên luôn luôn kiểm tra kiểu của đối tượng trước khi ép kiểu bằng toán tử `instanceof`.

```java
Animal someAnimal = new Cat(); // Giả sử có thêm lớp Cat

// ...

// Kiểm tra an toàn trước khi downcast
if (someAnimal instanceof Dog) {
    Dog dog = (Dog) someAnimal;
    dog.bark();
} else {
    System.out.println("Đây không phải là một con chó!");
}
// Kết quả: "Đây không phải là một con chó!"
```

### Tóm tắt nhanh

**Upcasting (An toàn):**

  * "Đây là một quả Táo. Tôi sẽ gọi nó là một Trái cây."
  * `TráiCây t = new Táo();`
  * Điều này luôn đúng. Chỉ có thể làm những việc chung chung của "Trái cây" (như `an()`).

**Downcasting (Rủi ro):**

  * "Tôi có một Trái cây. Tôi khẳng định nó là một quả Táo."
  * `Táo a = (Táo) t;`
  * Nếu `t` đúng là Táo, có thể làm việc riêng của "Táo" (như `lamBanhTao()`).
  * Nếu `t` thực ra là một quả Cam, chương trình sẽ "vỡ" (`ClassCastException`).

-----

## Lớp `Object` trong Java

### 1\. `class Object` trong Java là gì?

  * Trong Java, `Object` là **lớp gốc (root class)** của toàn bộ hệ thống phân cấp lớp (class hierarchy).
  * Tên đầy đủ của nó là: `java.lang.Object`.
  * Mọi lớp trong Java đều kế thừa (trực tiếp hoặc gián tiếp) từ `Object`.

Ví dụ:

```java
class A {}              // tự động extends Object
class B extends A {}    // gián tiếp kế thừa Object
```

  * Vì vậy, mọi đối tượng (object) trong Java — bất kể thuộc lớp nào — đều có những phương thức cơ bản được định nghĩa trong `Object`.

### 2\. Một số phương thức quan trọng của `Object`

| Phương thức                             | Mục đích                                                                 |
| :-------------------------------------- | :----------------------------------------------------------------------- |
| **`equals(Object obj)`**                | So sánh hai đối tượng có “bằng nhau” không (theo logic được định nghĩa). |
| **`hashCode()`**                        | Trả về mã băm, thường dùng trong `HashMap`, `HashSet`,…                  |
| **`toString()`**                        | Trả về chuỗi mô tả đối tượng (mặc định là tên lớp + mã hash).            |
| **`getClass()`**                        | Trả về đối tượng `Class` biểu diễn lớp runtime của đối tượng.            |
| **`clone()`**                           | Tạo bản sao nông (shallow copy) của đối tượng.                           |
| **`finalize()`**                        | Được gọi trước khi GC thu hồi đối tượng (hầu như không còn được dùng).   |
| **`wait()`, `notify()`, `notifyAll()`** | Liên quan đến đồng bộ hóa (multithreading).                              |

### 3\. Sự khác nhau giữa “class Object” và “object”

| So sánh     | `class Object`                                | `object`                                                   |
| :---------- | :-------------------------------------------- | :--------------------------------------------------------- |
| **Là gì?**  | Một **lớp cụ thể** trong package `java.lang`. | Một **thực thể (instance)** được tạo ra từ bất kỳ lớp nào. |
| **Vai trò** | Là lớp cha của mọi lớp.                       | Là thực thể cụ thể trong bộ nhớ.                           |
| **Ví dụ**   | `java.lang.Object`                            | `new Object()` hoặc `new String("hi")`                     |
| **Cấp độ**  | Kiểu dữ liệu (type)                           | Dữ liệu (value / instance)                                 |

**Ví dụ minh họa:**

```java
Object x = new Object();    // x là một object, kiểu Object
String s = "hello";         // s cũng là một object, kiểu String (kế thừa Object)
```

→ Ở đây:

  * `Object` (viết hoa) là tên lớp.
  * `x` và `s` là các `object` (đối tượng) — thực thể của các lớp.

### 4\. Tổng kết ngắn gọn

| Thuộc tính     | `class Object`                                       | `object`                                  |
| :------------- | :--------------------------------------------------- | :---------------------------------------- |
| **Định nghĩa** | Lớp cha của mọi lớp trong Java                       | Một thể hiện cụ thể của một lớp           |
| **Tên đầy đủ** | `java.lang.Object`                                   | Không có — là khái niệm chung             |
| **Vai trò**    | Cung cấp các phương thức cơ bản cho tất cả đối tượng | Đại diện cho dữ liệu thực tế trong bộ nhớ |
| **Ví dụ**      | `Object obj;`                                        | `obj = new Object();`                     |

-----

## Tính đa hình

Tính đa hình (Polymorphism) là một trong bốn trụ cột cơ bản của Lập trình Hướng đối tượng (OOP), bên cạnh Đóng gói (Encapsulation), Kế thừa (Inheritance), và Trừu tượng (Abstraction).

Từ "Polymorphism" có nghĩa là **"nhiều hình thái"**.

Trong Java, tính đa hình là khả năng của một **biến tham chiếu** có thể tham chiếu đến các **đối tượng thuộc nhiều kiểu khác nhau** (miễn là chúng có chung một lớp cha hoặc interface), và cho phép một **hành động** (phương thức) có thể được thực hiện theo những **cách khác nhau** tùy thuộc vào đối tượng thực tế đang gọi nó.

### Cách thức hoạt động của Tính đa hình

Để đạt được tính đa hình, Java cần ba yếu tố cốt lõi:

1.  **Kế thừa (Inheritance):** Phải có một mối quan hệ cha-con (*is-a*). Ví dụ: `Dog` *là-một* `Animal`, `Cat` *là-một* `Animal`.
2.  **Ghi đè phương thức (Method Overriding):** Lớp con phải cung cấp một định nghĩa riêng cho phương thức mà nó kế thừa từ lớp cha.
3.  **Upcasting (Ép kiểu lên):** Cơ chế then chốt. Sử dụng một biến tham chiếu của **kiểu lớp cha** để trỏ đến một đối tượng của **kiểu lớp con**.

### Ví dụ: Đa hình tại Runtime (Runtime Polymorphism)

Đây là hình thức đa hình quan trọng nhất.

**1. Tạo các lớp (Kế thừa và Ghi đè):**

```java
// Lớp cha
class Animal {
    public void makeSound() {
        System.out.println("Một tiếng động vật nào đó...");
    }
}

// Lớp con 1
class Dog extends Animal {
    // Ghi đè (Override) phương thức của cha
    @Override
    public void makeSound() {
        System.out.println("Gâu gâu!");
    }
}

// Lớp con 2
class Cat extends Animal {
    // Ghi đè (Override) phương thức của cha
    @Override
    public void makeSound() {
        System.out.println("Meo meo!");
    }
}
```

**2. Kích hoạt đa hình (Upcasting):**

Bây giờ, trong hàm `main`, sử dụng tham chiếu `Animal` (kiểu lớp cha) để trỏ đến các đối tượng `Dog` và `Cat` (kiểu lớp con).

```java
public class Main {
    public static void main(String[] args) {
        // animal1 là kiểu Animal, nhưng trỏ đến đối tượng Dog
        Animal animal1 = new Dog(); 
        
        // animal2 là kiểu Animal, nhưng trỏ đến đối tượng Cat
        Animal animal2 = new Cat(); 

        // GỌI CÙNG MỘT HÀNH ĐỘNG: makeSound()
        animal1.makeSound(); // JVM thấy animal1 là Dog -> In ra: "Gâu gâu!"
        animal2.makeSound(); // JVM thấy animal2 là Cat -> In ra: "Meo meo!"
    }
}
```

**Điều gì đã xảy ra?**

  * **Lúc biên dịch (Compile-time):** Trình biên dịch chỉ biết `animal1` và `animal2` là kiểu `Animal`, và lớp `Animal` *có* phương thức `makeSound()`. Vì vậy, code hợp lệ.
  * **Lúc chạy (Runtime):** Máy ảo Java (JVM) nhìn vào đối tượng *thực tế* mà `animal1` đang trỏ tới (đó là `Dog`). Nó sẽ gọi phương thức `makeSound()` của lớp `Dog`. Tương tự với `animal2` (đó là `Cat`).

Đây được gọi là **Dynamic Method Dispatch** (Điều phối phương thức động) hay **Runtime Polymorphism**.

### Lợi ích của Tính đa hình

Lợi ích lớn nhất là tạo ra code **linh hoạt** và **dễ mở rộng**.

Hãy tưởng tượng một phương thức để làm việc với động vật:

```java
// Phương thức này chấp nhận BẤT KỲ đối tượng nào "là-một" Animal
public static void playWithAnimal(Animal animal) {
    System.out.print("Đang chơi với: ");
    animal.makeSound();
}

// Bây giờ có thể gọi:
playWithAnimal(new Dog()); // In ra: Đang chơi với: Gâu gâu!
playWithAnimal(new Cat()); // In ra: Đang chơi với: Meo meo!
```

Nếu sau này tạo thêm lớp `Bird extends Animal`, chỉ cần ghi đè `makeSound()` (để kêu "Chip chip\!"). Phương thức `playWithAnimal()` **không cần thay đổi một dòng code nào** mà vẫn hoạt động đúng với `Bird`.

### Các loại Đa hình trong Java

Java có hai loại đa hình:

1.  **Đa hình lúc chạy (Runtime Polymorphism) - Đa hình động**

      * **Còn gọi là:** Dynamic Method Dispatch.
      * **Cách đạt được:** Ghi đè phương thức (Method **Overriding**).
      * **Giải thích:** Đây chính là ví dụ `Animal` ở trên. Phương thức nào được gọi sẽ được quyết định lúc chương trình chạy.

2.  **Đa hình lúc biên dịch (Compile-time Polymorphism) - Đa hình tĩnh**

      * **Còn gọi là:** Static Binding.
      * **Cách đạt được:** Nạp chồng phương thức (Method **Overloading**).
      * **Giải thích:** Đây là việc có nhiều phương thức *cùng tên* nhưng *khác tham số* (khác số lượng hoặc kiểu dữ liệu) trong cùng một lớp.
      * **Ví dụ:**
        ```java
        class Calculator {
            int add(int a, int b) {
                return a + b;
            }
            
            double add(double a, double b) {
                return a + b;
            }
        }

        // Trình biên dịch biết ngay phải gọi phương thức nào
        Calculator calc = new Calculator();
        calc.add(5, 10);     // Gọi phiên bản int
        calc.add(5.5, 10.1); // Gọi phiên bản double
        ```

-----

Có hai kiểu đa hình (polymorphism) trong Java, phân biệt dựa trên **thời điểm** mà Java quyết định chính xác phương thức nào sẽ được gọi.

  * **Đa hình Compile-time (Lúc biên dịch):** Quyết định được đưa ra khi biên dịch code.
  * **Đa hình Runtime (Lúc chạy):** Quyết định được đưa ra khi chương trình đang chạy.

### 1\. Compile-time Polymorphism (Đa hình tĩnh)

Còn được gọi là **Static Binding** (Liên kết tĩnh).

Cách thức hoạt động của nó trong Java là **Method Overloading** (Nạp chồng phương thức).

**Nạp chồng phương thức (Method Overloading):**
Đây là việc định nghĩa nhiều phương thức **có cùng tên** nhưng **khác nhau về tham số** (khác về số lượng, hoặc kiểu dữ liệu của tham số) trong *cùng một lớp*.

Khi gọi phương thức, trình biên dịch (compiler) sẽ nhìn vào số lượng và kiểu tham số được truyền vào để quyết định chính xác phương thức nào sẽ được gọi. Quyết định này được "khóa" lại ngay tại thời điểm biên dịch.

**Ví dụ:**

```java
class Calculator {
    
    // Phương thức 1
    int add(int a, int b) {
        return a + b;
    }
    
    // Phương thức 2 (Cùng tên 'add' nhưng khác tham số)
    double add(double a, double b) {
        return a + b;
    }
    
    // Phương thức 3 (Cùng tên 'add' nhưng khác số lượng tham số)
    int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        // Quyết định tại Compile-time:
        calc.add(5, 10);     // Compiler biết phải gọi phương thức 1
        calc.add(5.5, 10.2); // Compiler biết phải gọi phương thức 2
        calc.add(1, 2, 3);   // Compiler biết phải gọi phương thức 3
    }
}
```

-----

### 2\. Runtime Polymorphism (Đa hình động)

Còn được gọi là **Dynamic Method Dispatch** hoặc **Dynamic Binding** (Liên kết động). Đây là khái niệm đa hình quan trọng nhất trong OOP.

Cách thức hoạt động của nó là **Method Overriding** (Ghi đè phương thức), kết hợp với **Upcasting**.

**Ghi đè phương thức (Method Overriding):**
Đây là việc một lớp con cung cấp một định nghĩa (implementation) cụ thể cho một phương thức đã được định nghĩa ở lớp cha. Phương thức ở lớp con phải có **cùng tên, cùng kiểu trả về, và cùng tham số** với phương thức ở lớp cha.

**Hoạt động:**

1.  Dùng một biến tham chiếu của **kiểu lớp cha** (ví dụ: `Animal`).
2.  Cho nó trỏ đến một đối tượng của **kiểu lớp con** (ví dụ: `new Dog()`). Đây là **Upcasting**.
3.  Khi gọi phương thức qua biến tham chiếu đó (ví dụ: `animal.makeSound()`), JVM (Máy ảo Java) sẽ không gọi phương thức của `Animal`. Thay vào đó, nó sẽ đợi đến **lúc chạy** để xem đối tượng *thực sự* là gì (là `Dog` hay `Cat`?) và gọi phương thức đã được ghi đè của đối tượng đó.

**Ví dụ:**

```java
class Animal { // Lớp cha
    void makeSound() {
        System.out.println("Một tiếng động vật...");
    }
}

class Dog extends Animal { // Lớp con
    @Override // Ghi đè
    void makeSound() {
        System.out.println("Gâu gâu!");
    }
}

class Cat extends Animal { // Lớp con
    @Override // Ghi đè
    void makeSound() {
        System.out.println("Meo meo!");
    }
}

public class Main {
    public static void main(String[] args) {
        // Upcasting: Biến kiểu Animal, đối tượng là Dog
        Animal myAnimal = new Dog(); 
        
        // Quyết định tại Runtime:
        // JVM thấy 'myAnimal' đang giữ một đối tượng Dog,
        // nên nó gọi makeSound() của Dog.
        myAnimal.makeSound(); // In ra: "Gâu gâu!"
        
        // Bây giờ 'myAnimal' trỏ đến đối tượng Cat
        myAnimal = new Cat();
        
        // JVM thấy 'myAnimal' đang giữ một đối tượng Cat,
        // nên nó gọi makeSound() của Cat.
        myAnimal.makeSound(); // In ra: "Meo meo!"
    }
}
```

-----

### So sánh nhanh

| Đặc điểm            | Đa hình Compile-time (Tĩnh)                     | Đa hình Runtime (Động)                     |
| :------------------ | :---------------------------------------------- | :----------------------------------------- |
| **Tên khác**        | Static Binding, Early Binding                   | Dynamic Binding, Late Binding              |
| **Cách đạt được**   | **Method Overloading** (Nạp chồng)              | **Method Overriding** (Ghi đè)             |
| **Thời điểm**       | Quyết định lúc **biên dịch** (Compile-time)     | Quyết định lúc **chạy** (Runtime)          |
| **Cơ chế**          | Dựa trên **chữ ký phương thức** (tên + tham số) | Dựa trên **đối tượng thực tế** lúc runtime |
| **Yêu cầu kế thừa** | Không cần thiết                                 | **Bắt buộc** phải có kế thừa               |
| **Ví dụ**           | `calc.add(5, 10)` vs `calc.add(5.5, 10.2)`      | `Animal a = new Dog(); a.makeSound();`     |
| **Hiệu suất**       | Nhanh hơn (vì đã quyết định từ trước)           | Chậm hơn một chút (phải tra cứu lúc chạy)  |

-----

## Overload (Nạp chồng) và Override (Ghi đè)

Overload (Nạp chồng) và Override (Ghi đè) là hai khái niệm cơ bản của Java, đều liên quan đến phương thức nhưng hoàn toàn khác nhau về mục đích và cách thức hoạt động.

Đây là bảng so sánh trực tiếp để phân biệt chúng:

| Đặc điểm                 | 📖 Overloaded (Nạp chồng)                                                                                                 | 🎯 Overridden (Ghi đè)                                                                                                   |
| :----------------------- | :----------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------- |
| **Mục đích**             | Cho phép một lớp có nhiều phương thức **cùng tên** nhưng thực hiện các chức năng khác nhau dựa trên **tham số đầu vào**. | Cho phép lớp con cung cấp một **cách triển khai (implementation) cụ thể** cho phương thức đã được định nghĩa ở lớp cha. |
| **Vị trí**               | Xảy ra **bên trong một lớp** (within a single class).                                                                    | Xảy ra giữa **hai lớp** (lớp cha và lớp con).                                                                           |
| **Tham số**              | **BẮT BUỘC phải khác nhau** (về số lượng, kiểu dữ liệu, hoặc thứ tự của tham số).                                        | **BẮT BUỘC phải giống hệt nhau** (cùng tên, cùng số lượng, cùng kiểu tham số).                                          |
| **Kiểu trả về**          | Có thể giống hoặc khác nhau.                                                                                             | Phải giống hệt, hoặc là một *kiểu con* (covariant return type).                                                         |
| **Loại Đa hình**         | Đa hình lúc **Compile-time** (Đa hình tĩnh).                                                                             | Đa hình lúc **Runtime** (Đa hình động).                                                                                 |
| **Liên kết**             | **Static Binding** (Liên kết tĩnh).                                                                                      | **Dynamic Binding** (Liên kết động).                                                                                    |
| **Từ khóa `@Override`**  | Không dùng.                                                                                                              | **Nên dùng**. Nó giúp trình biên dịch kiểm tra xem việc ghi đè có đúng không.                                           |
| **Phương thức `static`** | **CÓ THỂ** nạp chồng (overload) phương thức `static`.                                                                    | **KHÔNG THỂ** ghi đè (override) phương thức `static`. (Đây gọi là "che giấu" - method hiding).                          |

-----

###  Ví dụ về Method Overloading (Nạp chồng)

```java
class DisplayBox {
    
    // 1. Phương thức 'display' với tham số String
    public void display(String text) {
        System.out.println("Hiển thị text: " + text);
    }
    
    // 2. Nạp chồng 'display' với tham số int
    public void display(int number) {
        System.out.println("Hiển thị số: " + number);
    }
    
    // 3. Nạp chồng 'display' với hai tham số
    public void display(String text, int number) {
        System.out.println(text + " " + number);
    }
}

// Cách gọi:
DisplayBox box = new DisplayBox();
box.display("Hello"); // Gọi phương thức 1
box.display(100);     // Gọi phương thức 2
```

Trình biên dịch biết ngay phải gọi phương thức nào dựa vào tham số được truyền vào.

-----

### Ví dụ về Method Overriding (Ghi đè)

```java
// Lớp cha
class Animal {
    public void makeSound() {
        System.out.println("Động vật phát ra tiếng kêu");
    }
}

// Lớp con
class Dog extends Animal {
    
    // Ghi đè phương thức CÙNG TÊN, CÙNG THAM SỐ
    @Override
    public void makeSound() {
        System.out.println("Gâu gâu!");
    }
}

// Cách gọi (sử dụng tính đa hình):
Animal myPet = new Dog(); // Upcasting
myPet.makeSound(); // JVM lúc runtime sẽ gọi phương thức của Dog
                   // In ra: "Gâu gâu!"
```

JVM chỉ quyết định gọi phương thức `makeSound` của `Dog` vào lúc chương trình chạy.

-----

  * **Overloading** = Nhiều phương thức, cùng tên, **khác tham số**, **cùng một lớp**.
  * **Overriding** = Một phương thức, cùng tên, **cùng tham số**, ở **lớp cha và lớp con**.