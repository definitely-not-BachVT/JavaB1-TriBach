# 1\. Khái niệm Object và Class

## Class (Lớp)

**Class** có thể hiểu là một bản thiết kế "blueprint" hoặc một khuôn mẫu "template" để tạo ra các đối tượng.

> **Ví dụ so sánh:**
>
>   * **Class** là bản thiết kế chi tiết của một "Chiếc xe hơi".
>   * Bản thiết kế này định nghĩa các **đặc điểm** (thuộc tính) chung như `mauSac`, `soBanh` và các **hành vi** (phương thức) chung như `chay()`, `phanh()`.

## Object (Đối tượng)

**Object** là một thực thể (instance) cụ thể được tạo ra từ một **Class**.

> **Ví dụ so sánh (tiếp theo):**
>
>   * **Object** là một chiếc xe hơi cụ thể được "sản xuất" từ bản thiết kế.
>   * **Ví dụ**:  **Object** `xeToyota` (màu đỏ) hoặc một đối tượng `xeFord` (màu xanh).

Có thể liên tưởng: `Class` tương đương với một kiểu dữ liệu (như `int`), trong khi `Object` là một biến cụ thể (như `a` trong khai báo `int a;`).

-----

## Đặc điểm của Object

Một đối tượng bao gồm hai thành phần chính:

### 1\. Trạng thái (State)

Đây là các dữ liệu, thông tin hoặc thuộc tính mô tả đối tượng. Trong Java, chúng được biểu diễn bằng các **trường (fields)** hay còn gọi là **biến (variables)**.

  * **Ví dụ (với object `XeHoi`):**
      * `String mauSac = "Đỏ"`
      * `String tenHang = "Toyota"`
      * `int tocDoHienTai = 0`

### 2\. Hành vi (Behavior)

Đây là các hành động mà đối tượng có thể thực hiện, hoặc các phép toán xử lý dữ liệu của chính nó. Trong Java, chúng được biểu diễn bằng các **phương thức (methods)**.

  * **Ví dụ (với object `XeHoi`):**
      * `void tangToc(int soKm)`
      * `void phanh()`
      * `void doiMauSon(String mauMoi)`

-----

## Code minh họa: Class và Object

```java
// Bước 1: Định nghĩa Class (Bản thiết kế)
class XeHoi {

    // 1. Trạng thái (Fields)
    String mauSac;
    int tocDo;

    // 2. Hành vi (Methods)
    void tangToc() {
        tocDo = tocDo + 10;
        System.out.println("Tốc độ hiện tại: " + tocDo + " km/h");
    }

    void phanh() {
        tocDo = 0;
        System.out.println("Xe đã dừng.");
    }
}

// Bước 2: Tạo các Object (Đối tượng) từ Class
public class Main {
    public static void main(String[] args) {

        // Tạo object thứ nhất tên là 'xeCuaToi'
        // 'new XeHoi()' chính là quá trình "xây" một chiếc xe từ bản thiết kế
        XeHoi xeCuaToi = new XeHoi();
        
        // Gán trạng thái cho object 'xeCuaToi'
        xeCuaToi.mauSac = "Đỏ";
        xeCuaToi.tocDo = 0;

        // Gọi hành vi của object 'xeCuaToi'
        xeCuaToi.tangToc(); // Output: Tốc độ hiện tại: 10 km/h
        xeCuaToi.tangToc(); // Output: Tốc độ hiện tại: 20 km/h

        System.out.println("--------------------");

        // Tạo object thứ hai tên là 'xeCuaBan'
        XeHoi xeCuaBan = new XeHoi();
        
        // Gán trạng thái cho object 'xeCuaBan'
        xeCuaBan.mauSac = "Xanh";
        xeCuaBan.tocDo = 5; // Trạng thái này độc lập với 'xeCuaToi'
        
        xeCuaBan.tangToc(); // Output: Tốc độ hiện tại: 15 km/h
    }
}
```

-----

# 2\. Cơ chế lưu trữ Object

Trong Java, các đối tượng (objects) được lưu trữ trên **Heap (Bộ nhớ Heap)**.

Thứ được lưu trữ trên **Stack (Bộ nhớ Ngăn xếp)** không phải là bản thân đối tượng, mà là **biến tham chiếu (reference)** trỏ đến vị trí của đối tượng đó trên Heap.

## Bộ nhớ Heap (Heap Memory) 

Đây là khu vực bộ nhớ chính nơi **tất cả các đối tượng** (mọi thứ được tạo bằng từ khóa `new`) và mảng (arrays) được lưu trữ.

  * **Quản lý:** Được quản lý tự động bởi Máy ảo Java (JVM). Khi một đối tượng không còn được tham chiếu, **Garbage Collector (GC)** sẽ tự động thu hồi và giải phóng vùng nhớ đó.
  * **Chia sẻ:** Bộ nhớ Heap được chia sẻ chung cho tất cả các luồng (threads) trong ứng dụng.
  * **Kích thước:** Thường có kích thước lớn hơn Stack rất nhiều.

## Bộ nhớ Stack (Stack Memory) 

Đây là khu vực bộ nhớ được dùng cho việc **thực thi phương thức (method execution)** và lưu trữ các **biến cục bộ (local variables)**.

  * **Quản lý:** Stack hoạt động theo cơ chế **LIFO (Last-In, First-Out)**.
  * **Hoạt động:**
    1.  Khi một phương thức được gọi, một "khung" (stack frame) mới được đẩy (push) vào đỉnh của Stack.
    2.  Khung này chứa các biến cục bộ của phương thức đó.
    3.  Khi phương thức kết thúc, khung của nó sẽ được tự động xóa (pop) khỏi Stack.
  * **Lưu trữ:** Stack lưu trữ hai loại dữ liệu:
      * **Kiểu nguyên thủy (Primitive Types):** Như `int`, `double`, `boolean`. Giá trị thực tế của biến được lưu trực tiếp trên Stack.
      * **Biến tham chiếu (Object References):** Đây chính là **địa chỉ** trỏ đến vị trí của một đối tượng thực tế đang nằm trên **Heap**.

> **Ví dụ minh họa (Analogy):**
>
> Tưởng tượng **Heap** là một nhà kho khổng lồ (nơi chứa tất cả hàng hóa). **Stack** là một tấm bảng kẹp giấy (clipboard) đang được sử dụng để làm việc.
>
> Khi thực thi đoạn code sau:
>
> ```java
> void doWork() {
>     int id = 10;
>     String name = new String("Java");
> }
> ```
>
> **1**.  Một khung (frame) mới cho `doWork()` được tạo trên **Stack**.
> **2**.  **`int id = 10;`**: `id` là kiểu nguyên thủy. Giá trị `10` được lưu trực tiếp vào khung trên **Stack**.
> **3**.  **`String name = new String("Java");`**:
>       * `new String("Java")`: JVM tạo một đối tượng `String` mới (hàng hóa) và đặt nó vào **Heap** (nhà kho).
>       * `String name`: Biến `name` (một biến tham chiếu) được lưu trên **Stack**.
>       * `=`: Phép gán này lấy *địa chỉ* của đối tượng trên Heap và chép nó vào biến `name` trên Stack.
>
> **Kết quả:**
>
>   * **Trên Stack:** Có biến `id` (giá trị 10) và biến `name` (chứa một địa chỉ, ví dụ `0xABC123`).
>   * **Trên Heap:** Tại địa chỉ `0xABC123`, có một đối tượng `String` chứa dữ liệu "Java".

## Cấu trúc của Object trên Heap

Bản thân đối tượng được lưu trên Heap cũng có cấu trúc, thường bao gồm:

1.  **Object Header (Phần đầu):** Chứa thông tin "siêu dữ liệu" (metadata) mà JVM cần, ví dụ: con trỏ đến thông tin Lớp (Class), thông tin khóa (locking) cho đa luồng, các bit cờ (flags) cho Garbage Collector.
2.  **Instance Variables (Biến instance):** Dữ liệu thực tế của đối tượng (các trường đã khai báo).
      * Nếu là kiểu nguyên thủy (`int`), giá trị được lưu ngay tại đây.
      * Nếu là tham chiếu đến đối tượng khác (ví dụ, một `Person` có thuộc tính `Address`), nó sẽ lưu một *địa chỉ* trỏ đến một đối tượng `Address` *khác* cũng nằm trên Heap.
3.  **Padding (Phần đệm):** Một vài byte đệm để đảm bảo kích thước đối tượng được căn chỉnh (alignment), giúp CPU truy cập hiệu quả hơn.

-----

# 3\. Lớp Wrapper (Wrapper Classes)

**Lớp Wrapper (Lớp vỏ bọc)** trong Java là một lớp dùng để bao bọc (wrap) một kiểu dữ liệu nguyên thủy (primitive type), biến nó thành một đối tượng (object).

  * **Nguyên thủy:** `int x = 10;` (Đây chỉ là một giá trị)
  * **Wrapper:** `Integer xObject = Integer.valueOf(10);` (Đây là một đối tượng đầy đủ trên Heap, có các phương thức riêng)

## Vài trò của lớp Wrapper

Các kiểu dữ liệu nguyên thủy không phải là đối tượng, điều này tạo ra một số hạn chế. Lớp Wrapper ra đời để giải quyết chúng:

1.  **Sử dụng trong Collections Framework:** Đây là lý do quan trọng nhất. Các cấu trúc dữ liệu như `ArrayList`, `HashMap`... chỉ có thể lưu trữ **đối tượng**. Không thể tạo `ArrayList<int>`, mà phải dùng `ArrayList<Integer>`.
2.  **Cho phép giá trị `null`:**
      * Một biến `int` phải có giá trị (mặc định là `0`).
      * Một đối tượng `Integer` có thể mang giá trị `null`, biểu thị "không có giá trị". Điều này rất hữu ích khi làm việc với cơ sở dữ liệu.
3.  **Cung cấp các phương thức tiện ích:** 🔧 Các lớp Wrapper chứa nhiều phương thức tĩnh (static methods) hữu ích để xử lý dữ liệu.
      * `Integer.parseInt("123")`: Chuyển chuỗi thành `int`.
      * `Double.toString(3.14)`: Chuyển `double` thành chuỗi.
      * `Character.isDigit('5')`: Kiểm tra ký tự có phải là số không.

## Bảng các Lớp Wrapper tương ứng

Mỗi kiểu nguyên thủy đều có một lớp Wrapper tương ứng (nằm trong gói `java.lang`):

| Kiểu nguyên thủy (Primitive) | Lớp Wrapper (Object) |
| :--------------------------- | :------------------- |
| `int`                        | **`Integer`**        |
| `char`                       | **`Character`**      |
| `double`                     | **`Double`**         |
| `long`                       | **`Long`**           |
| `boolean`                    | **`Boolean`**        |
| `float`                      | **`Float`**          |
| `byte`                       | **`Byte`**           |
| `short`                      | **`Short`**          |

-----

# 4\. Autoboxing và Unboxing 

**Autoboxing** và **Unboxing** là tính năng (từ Java 5) cho phép trình biên dịch **tự động chuyển đổi** giữa kiểu dữ liệu nguyên thủy và Lớp Wrapper tương ứng.

  * **Autoboxing (Tự động đóng hộp):** Tự động chuyển từ nguyên thủy sang đối tượng (ví dụ: `int` → `Integer`).
  * **Unboxing (Tự động mở hộp):** Tự động chuyển từ đối tượng về nguyên thủy (ví dụ: `Integer` → `int`).


Trước Java 5, việc "đóng/mở hộp" phải làm thủ công:

```java
// CÁCH LÀM CŨ (Thủ công)
ArrayList<Integer> list = new ArrayList<>();
int num = 10;
list.add(Integer.valueOf(num)); // Phải "đóng hộp" thủ công

// Lấy ra cũng phải "mở hộp" thủ công
int retrievedNum = list.get(0).intValue();
```

Với Autoboxing/Unboxing, code trở nên sạch sẽ và trực quan hơn.

## Ví dụ về Autoboxing (Nguyên thủy → Đối tượng)

Autoboxing xảy ra khi:

1.  Gán một giá trị nguyên thủy cho một biến kiểu Wrapper.
2.  Truyền một giá trị nguyên thủy làm tham số cho phương thức mong đợi kiểu Wrapper.

<!-- end list -->

```java
// 1. Gán trực tiếp
// Trình biên dịch tự động chuyển 100 (int) thành Integer.valueOf(100)
Integer myIntObject = 100;

// 2. Dùng trong Collections
ArrayList<Integer> numberList = new ArrayList<>();

// Autoboxing: Java tự động "đóng hộp" số 5 (int)
// thành một đối tượng Integer để thêm vào danh sách.
numberList.add(5);
numberList.add(10);
```

## Ví dụ về Unboxing (Đối tượng → Nguyên thủy)

Unboxing xảy ra khi:

1.  Gán một đối tượng Wrapper cho một biến kiểu nguyên thủy.
2.  Sử dụng một đối tượng Wrapper trong các phép toán số học.

<!-- end list -->

```java
Integer myIntObject = 100; // Autoboxing

// 1. Gán trực tiếp
// Unboxing: Tự động gọi myIntObject.intValue()
int myIntPrimitive = myIntObject;

// 2. Dùng trong phép toán
// Unboxing: myIntObject được tự động "mở hộp" thành int 100
// trước khi thực hiện phép cộng.
int sum = myIntObject + 50; // (100 + 50)

System.out.println(sum); // In ra 150
```

> 🚨 **Cảnh báo quan trọng: `NullPointerException`**
>
> Đây là lỗi phổ biến dễ xảy ra của Unboxing.
>
>   * Kiểu nguyên thủy (`int`) **không thể** là `null` (mặc định là `0`).
>   * Đối tượng Wrapper (`Integer`) **có thể** là `null`.
>
> Nếu cố gắng "mở hộp" (Unbox) một đối tượng Wrapper đang bị `null` để gán vào một biến nguyên thủy, chương trình sẽ ném ra lỗi **`NullPointerException`**.
>
> **Ví dụ gây lỗi:**
>
> ```java
> Integer myScore = null;
> ```

> // Java cố gắng gọi myScore.intValue() (Unboxing)
> // Nhưng myScore là null, nên gây ra NullPointerException
> int score = myScore;
>
> ````
> 
> Cách phòng tránh: Luôn kiểm tra `null` trước khi thực hiện Unboxing.

> ```java
> Integer myScore = null;
> int score = 0; // Giá trị mặc định
> ````

> if (myScore \!= null) {
> score = myScore; // Chỉ unbox khi nó không null
> }
> System.out.println(score); // In ra 0
>
> ```
> ```

-----

# 5\. String vs. StringBuilder

Sự khác biệt cốt lõi là:

  * **`String`** là **bất biến** (Immutable).
  * **`StringBuilder`** là **khả biến** (Mutable).

Điều này ảnh hưởng rất lớn đến hiệu năng khi xử lý chuỗi.

## `String` (Bất biến)

**Bất biến (Immutable)** có nghĩa là một khi đối tượng `String` được tạo ra, nội dung của nó **không thể thay đổi**.

Khi thực hiện một phép "thay đổi" `String`:

```java
String s = "Xin chào";
s = s + " Java"; // Đây không phải là "thay đổi"
```

Điều thực sự xảy ra là:

1.  JVM tạo ra một đối tượng `String` là `"Xin chào"`. Biến `s` trỏ đến nó.
2.  Khi `s + " Java"`, JVM tạo ra một đối tượng `String` **hoàn toàn mới** là `"Xin chào Java"`.
3.  Biến `s` bây giờ được cập nhật để trỏ đến đối tượng *mới* này.
4.  Đối tượng `"Xin chào"` ban đầu trở thành "rác" và sẽ bị Garbage Collector (GC) dọn dẹp.

**Hệ quả:** Nối chuỗi `String` liên tục trong một vòng lặp sẽ tạo ra rất nhiều đối tượng rác và làm giảm hiệu năng nghiêm trọng.

```java
// CÁCH LÀM RẤT TỆ (Dùng String trong vòng lặp)
String result = "";
for (int i = 0; i < 1000; i++) {
    result = result + i; // Mỗi lần lặp TẠO RA 1 ĐỐI TƯỢNG String mới!
}
```

## `StringBuilder` (Khả biến)

**Khả biến (Mutable)** có nghĩa là nội dung của đối tượng **có thể thay đổi** sau khi nó được tạo ra.

`StringBuilder` quản lý một bộ đệm (buffer) bên trong và cho phép thêm, chèn, xóa ký tự mà **không cần tạo đối tượng mới** mỗi lần.

```java
// CÁCH LÀM TỐT (Dùng StringBuilder)
StringBuilder sb = new StringBuilder(); // 1. Tạo 1 đối tượng duy nhất
for (int i = 0; i < 1000; i++) {
    sb.append(i); // 2. Chỉ SỬA ĐỔI đối tượng đó, không tạo mới
}
String result = sb.toString(); // 3. Chỉ tạo String kết quả 1 lần duy nhất
```

Cách này hiệu quả hơn rất nhiều vì nó chỉ làm việc trên một đối tượng duy nhất.

## So sánh

| Tính chất                 | `String`                     | `StringBuilder`        |
| :------------------------ | :--------------------------- | :--------------------- |
| **Khả năng thay đổi**     | **Bất biến** (Immutable)     | **Khả biến** (Mutable) |
| **Hiệu năng (Nối chuỗi)** | **Chậm** (nếu nối nhiều lần) | **Rất nhanh**          |
| **An toàn Đa luồng**      | An toàn (Vì không đổi)       | **Không** an toàn      |
| **Bộ nhớ**                | Tốn nhiều nếu nối liên tục   | Tiết kiệm hơn          |

## Tình huống sử dụng

  * **Dùng `String` khi:**
      * Chuỗi là cố định, không thay đổi (ví dụ: hằng số, tên cấu hình).
      * Chỉ nối chuỗi đơn giản 1-2 lần.
  * **Dùng `StringBuilder` khi:**
      * Cần xây dựng một chuỗi phức tạp từ nhiều phần.
      * Cần **nối chuỗi bên trong một vòng lặp (loop)**.

### Ghi chú: `StringBuffer`

`StringBuffer` giống hệt `StringBuilder` (cũng là khả biến) nhưng có thêm một điểm khác biệt:

  * **`StringBuffer`** là **thread-safe** (an toàn cho đa luồng).
  * **`StringBuilder`** là **không thread-safe**.

Vì `StringBuilder` không phải lo về an toàn đa luồng, nó **nhanh hơn** `StringBuffer`. Trong môi trường đơn luồng (đa số trường hợp), **luôn ưu tiên dùng `StringBuilder`**.

-----

# 6\. So sánh: `==` vs. `.equals()` vs. `.hashCode()`

Đây là ba khái niệm nền tảng khi làm việc với đối tượng, đặc biệt là trong các Collections.

  * **`==`** (toán tử): So sánh **tham chiếu** (địa chỉ bộ nhớ).
  * **`.equals()`** (phương thức): So sánh **nội dung** (ý nghĩa logic).
  * **`.hashCode()`** (phương thức): Trả về một **mã băm** (số nguyên) để tối ưu việc lưu trữ/tìm kiếm.

## 1\. Toán tử `==` (So sánh tham chiếu) 

Toán tử `==` kiểm tra xem hai biến có trỏ đến **cùng một vị trí** trong bộ nhớ hay không ("Đây có phải là CÙNG MỘT đối tượng không?").

  * **Với kiểu nguyên thủy (`int`, `char`...):** Nó so sánh **giá trị** thực tế.
    ```java
    int a = 10;
    int b = 10;
    // a == b là TRUE
    ```
  * **Với đối tượng (`String`, `Integer`...):** Nó so sánh **địa chỉ bộ nhớ**.
    ```java
    // s1 và s2 trỏ đến CÙNG MỘT đối tượng trong "String Pool"
    String s1 = "Hello";
    String s2 = "Hello";

    // s3 là một đối tượng MỚI, được tạo riêng trên Heap
    String s3 = new String("Hello");

    System.out.println(s1 == s2); // TRUE (cùng địa chỉ)
    System.out.println(s1 == s3); // FALSE (khác địa chỉ)
    ```

## 2\. Phương thức `.equals()` (So sánh nội dung) 

Phương thức `.equals()` kiểm tra xem hai đối tượng có **tương đương về mặt logic** (có cùng nội dung) hay không.

  * **Mặc định:** Nếu không được override (định nghĩa lại), `.equals()` (thừa kế từ lớp `Object`) hoạt động **giống hệt `==`**.
  * **Khi được override:** Các lớp như `String`, `Integer`... đều đã override phương thức này để nó so sánh **nội dung** bên trong.

<!-- end list -->

```java
String s1 = "Hello";
String s3 = new String("Hello");

// Mặc dù s1 và s3 khác địa chỉ (s1 == s3 là FALSE)
// Nhưng nội dung ("H-e-l-l-o") là giống hệt nhau
System.out.println(s1.equals(s3)); // TRUE
```

Khi tạo một lớp tùy chỉnh (ví dụ `Student`), lập trình viên phải tự override `equals()` để quy định khi nào hai `Student` được coi là "bằng nhau" (ví dụ: khi có cùng `studentID`).

## 3\. Phương thức `.hashCode()` (Mã băm) 

Phương thức `.hashCode()` trả về một số nguyên (`int`), gọi là mã băm.

**Mục đích:** Nó **KHÔNG** dùng để so sánh bằng nhau. Mục đích chính là để sử dụng trong các cấu trúc dữ liệu dựa trên bảng băm (hash-based collections) như `HashMap`, `HashSet`.

`HashMap` dùng `hashCode()` để quyết định nên đặt đối tượng vào "xô" (bucket) nào, giúp việc tìm kiếm/thêm/xóa cực kỳ nhanh (thời gian $O(1)$).

## 4\. "Hợp đồng" (Contract) giữa `equals()` và `hashCode()` 

Khi override `equals()`, **BẮT BUỘC** phải override `hashCode()` theo quy tắc sau:

1.  Nếu `a.equals(b)` là **`true`**, thì `a.hashCode()` **PHẢI** bằng `b.hashCode()`.
    *(Hai đối tượng bằng nhau phải có cùng mã băm).*
2.  Nếu `a.hashCode()` bằng `b.hashCode()`, thì `a.equals(b)` **KHÔNG** nhất thiết phải là `true`.
    *(Hai đối tượng khác nhau CÓ THỂ vô tình có cùng mã băm. Đây gọi là "va chạm" - hash collision).*

**Hệ quả nếu vi phạm:** Các cấu trúc như `HashMap` sẽ hoạt động sai. Một đối tượng có thể được `put` vào một "xô", nhưng khi `get` lại tìm ở một "xô" khác (do `hashCode` khác nhau), dẫn đến không bao giờ tìm thấy.

## 5\. Chú ý

1.  Dùng `==` để so sánh các kiểu nguyên thủy.
2.  Dùng `==` để kiểm tra xem hai biến có trỏ đến **cùng một đối tượng** hay không.
3.  Dùng `.equals()` để kiểm tra xem hai đối tượng có **nội dung bằng nhau** hay không.
4.  Khi **override `equals()`**, hãy **luôn override `hashCode()`**.

-----

# 7\. Cơ chế truyền tham số: Pass-by-Value

 **Java chỉ "pass-by-value" (truyền bằng giá trị).**

Sự nhầm lẫn phổ biến (ví dụ như với `String`) đến từ việc hiểu sai về đối tượng và tham chiếu, chứ không phải hiểu sai về "pass-by-value".

## Pass-by-Value

"Pass-by-value" có nghĩa là khi một phương thức được gọi, Java sẽ **tạo một bản sao (copy)** của biến và truyền bản sao đó vào phương thức. Phương thức chỉ làm việc trên **bản sao**, không phải bản gốc.

### Trường hợp 1: Kiểu Nguyên thủy (ví dụ: `int`)

Khi truyền một biến `int`, Java sẽ sao chép **giá trị** của nó.

```java
public static void main(String[] args) {
    int myNumber = 10;
    changeNumber(myNumber);
    System.out.println(myNumber); // Sẽ in ra 10
}

public static void changeNumber(int x) {
    // x là BẢN SAO của myNumber (cũng có giá trị 10)
    x = 20; // Chỉ thay đổi bản sao, bản gốc 'myNumber' không đổi
}
```

### Trường hợp 2: Đối tượng (ví dụ: `StringBuilder`, `String`)

Khi truyền một đối tượng, Java **không** sao chép toàn bộ đối tượng. Thay vào đó, nó sao chép **giá trị của biến tham chiếu** (tức là địa chỉ bộ nhớ).

> **Ví dụ so sánh:**
>
> 1.  Một ngôi nhà được xây (đối tượng trên Heap).
> 2.  Một tham chiếu gốc (`myBuilder`) giữ địa chỉ của ngôi nhà (chìa khóa gốc).
> 3.  Khi gọi phương thức `changeBuilder(myBuilder)`, Java tạo một *bản sao của chìa khóa* (tham chiếu `sb`) và đưa nó cho phương thức.
> 4.  Bây giờ có hai chìa khóa (`myBuilder` và `sb`) cùng trỏ đến **một ngôi nhà duy nhất**.
> 5.  Phương thức `changeBuilder` có thể dùng chìa khóa sao (`sb`) để vào nhà và *sơn lại tường* (thay đổi nội dung bên trong của đối tượng).

## String thay đổi được không?

Sự thật là: **`String` KHÔNG THAY ĐỔI ĐƯỢC.**

Như đã giải thích ở trên, `String` là **bất biến (immutable)**. Bất kỳ nỗ lực "thay đổi" nào thực chất chỉ là tạo ra một đối tượng `String` mới.

```java
public static void main(String[] args) {
    String myString = "Hello";
    changeString(myString);
    System.out.println(myString); // Sẽ in ra "Hello"
}

public static void changeString(String s) {
    // s là BẢN SAO của tham chiếu (cả hai cùng trỏ đến "Hello")
    
    // Dòng này tạo ra một đối tượng "Hello World" MỚI
    // và làm cho BẢN SAO 's' trỏ đến đối tượng MỚI đó.
    s = s + " World"; 
    
    // Tham chiếu 'myString' ban đầu không hề bị ảnh hưởng.
    // Nó vẫn trỏ đến đối tượng "Hello" cũ.
}
```

Kết quả là `"Hello"`, chứng minh Java là pass-by-value.

## Phân biệt với đối tượng Khả biến (Mutable)

Với đối tượng khả biến (như `StringBuilder`), phương thức có thể thay đổi nội dung của đối tượng gốc, vì cả hai tham chiếu (gốc và bản sao) đều trỏ đến cùng một đối tượng.

```java
public static void main(String[] args) {
    StringBuilder myBuilder = new StringBuilder("Hello");
    changeBuilder(myBuilder);
    System.out.println(myBuilder.toString()); // Sẽ in ra "Hello World"
}

public static void changeBuilder(StringBuilder sb) {
    // sb là BẢN SAO của tham chiếu (cùng trỏ đến 1 đối tượng StringBuilder)
    
    // Dòng này KHÔNG tạo đối tượng mới.
    // Nó dùng tham chiếu sb để thay đổi NỘI DUNG BÊN TRONG
    // của đối tượng StringBuilder GỐC.
    sb.append(" World"); 
}
```

-----

# 8\. Khái niệm về Garbage Collector (GC) 

**Garbage Collector (GC)**, hay "Bộ Dọn Rác", là một tiến trình **tự động** chạy ngầm trong JVM với mục đích duy nhất: **tự động giải phóng bộ nhớ** đã cấp phát cho các đối tượng không còn được sử dụng nữa.

## Vai trò của GC

Trong các ngôn ngữ như C/C++, lập trình viên phải quản lý bộ nhớ thủ công (dùng `malloc()` và `free()`). Nếu cấp phát mà quên giải phóng, sẽ xảy ra **rò rỉ bộ nhớ (memory leak)**, khiến ứng dụng cạn kiệt bộ nhớ và sập.

**Giải pháp của Java:** GC tự động hóa hoàn toàn việc "trả lại" bộ nhớ. Lập trình viên chỉ cần tạo đối tượng (`new`), GC sẽ lo phần còn lại.

## Các khái niệm cốt lõi

### GC hoạt động ở đâu?

GC chỉ hoạt động và quản lý các đối tượng nằm trên **Bộ nhớ Heap (Heap Memory)**. Bộ nhớ Stack (Stack Memory) không cần GC vì nó tự động giải phóng các biến khi một phương thức (method) kết thúc.

### "Rác" (Garbage) là gì?

Một đối tượng bị coi là "rác" khi nó **không thể truy cập được (unreachable)**. Nghĩa là không còn bất kỳ tham chiếu "còn sống" nào trỏ đến đối tượng đó.

### GC Roots (Các điểm gốc)

Để biết một đối tượng có "còn sống" hay không, GC bắt đầu quét từ một tập hợp các tham chiếu đặc biệt gọi là **GC Roots**. Đây là những "điểm neo" mà GC biết chắc chắn là đang được sử dụng.

  * Các biến cục bộ đang hoạt động (nằm trên Stack).
  * Các biến `static` của các lớp.

### Quá trình "Mark and Sweep" (Đánh dấu và Dọn dẹp)

Đây là thuật toán GC cơ bản nhất:

1.  **Giai đoạn Đánh dấu (Mark):**
      * GC bắt đầu từ các **GC Roots**.
      * Nó đi theo mọi tham chiếu và "đánh dấu" (mark) tất cả các đối tượng mà nó có thể "chạm" tới là **"còn sống"**.
2.  **Giai đoạn Dọn dẹp (Sweep):**
      * Sau khi đánh dấu xong, GC quét (sweep) toàn bộ Heap.
      * Bất kỳ đối tượng nào **không** được đánh dấu sẽ bị coi là "rác" và bộ nhớ của nó sẽ bị thu hồi.

## GC theo thế hệ (Generational GC)

Quét toàn bộ Heap liên tục là rất tốn kém. Dựa trên "Giả thuyết thế hệ" (Hầu hết các đối tượng đều "chết trẻ"), JVM chia Heap thành các "thế hệ":

### 1\. Young Generation (Thế hệ Trẻ) 

Đây là nơi **tất cả các đối tượng mới** được tạo ra (trong vùng "Eden").

  * Vùng này được GC quét **rất thường xuyên** (gọi là **Minor GC**) vì chứa nhiều "rác" nhất.
  * Quá trình này rất nhanh. Các đối tượng "sống sót" qua vài lần Minor GC sẽ được "thăng cấp" (promoted) lên Thế hệ Già.

### 2\. Old Generation (Thế hệ Già - "Tenured") 

Đây là nơi chứa các đối tượng đã "sống lâu" (ví dụ: các đối tượng `static`, connection pool).

  * Vùng này được GC quét **ít thường xuyên hơn** (gọi là **Major GC** hoặc **Full GC**).
  * Quá trình này chậm hơn đáng kể.

**Lợi ích:** Bằng cách tập trung dọn dẹp thường xuyên ở vùng "trẻ", GC hoạt động hiệu quả hơn nhiều.

## "Stop-the-World" (Tạm dừng thế giới)

Khi GC chạy, nó cần một "bức ảnh" ổn định của bộ nhớ. Để làm điều này, GC thường phải **tạm dừng tất cả các luồng (threads) của ứng dụng** trong một khoảng thời gian ngắn. Khoảng dừng này được gọi là **"Stop-the-World" (STW)**.

Mục tiêu của các thuật toán GC hiện đại (như G1 GC, ZGC) là giảm thiểu thời gian "tạm dừng" này xuống mức thấp nhất.