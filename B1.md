

---

# Ngôn ngữ lập trình Java

**Java** là một ngôn ngữ lập trình hướng đối tượng, được Sun Microsystems (nay thuộc Oracle) phát triển vào năm 1995. **Java** được thiết kế với mục tiêu “**viết một lần, chạy mọi nơi**” (Write Once, Run Anywhere). Chương trình viết bằng Java có thể chạy trên nhiều nền tảng khác nhau mà không cần chỉnh sửa mã nguồn.

**Java** ra đời nhằm tạo ra một ngôn ngữ dễ dùng, an toàn, đa nền tảng có thể chạy được trên mọi thiết bị và hệ điều hành, đặc biệt là trong môi trường Internet đang phát triển mạnh vào thời điểm đó. Java được tạo ra để loại bỏ những lỗi thường gặp trong C/C++ (con trỏ, bộ thu gom rác và quản lý bộ nhớ, …)

## Cách Java hoạt động

**Java** không trực tiếp chạy code của chúng ta trên máy tính. Nó sử dụng một “máy ảo” (Virtual Machine) để chạy.

1.  **Viết code Java:** Người dùng viết code Java muốn chạy.
2.  **Biên dịch:** Nếu code không có vấn đề về ngữ pháp, trình biên dịch Java (`javac`) sẽ tạo ra một tệp mới (ví dụ: `MyProgram.class`). Tệp `MyProgram.class` không chứa mã máy mà CPU có thể hiểu, thay vào đó là **Java Bytecode** – một ngôn ngữ trung gian được thiết kế để không phụ thuộc vào bất cứ hệ điều hành hay kiến trúc CPU nào.
3.  **Khởi chạy:** Khi chạy tệp `.class` chứa bytecode, ta sẽ chạy **Máy ảo JVM (Java Virtual Machine)**.
4.  **Thực thi (Bên trong JVM):**
      * **a. Class Loader (Bộ nạp lớp):** JVM tìm và nạp `MyProgram.class` cùng với các thư viện cần thiết vào bộ nhớ RAM.
      * **b. Bytecode Verifier (Trình xác minh Bytecode):** Trình xác minh sẽ quét qua bytecode để đảm bảo rằng nó hợp lệ và an toàn—ví dụ: nó không cố gắng truy cập bộ nhớ một cách bất hợp pháp.
      * **c. Execution Engine (Bộ máy thực thi):** Bytecode được "dịch" thành mã máy gốc mà CPU máy tính có thể hiểu và thực thi.
          * **i. Thông dịch (Interpreter):** JVM đọc bytecode từng dòng một và dịch rồi thực thi ngay lập tức. Interpreter khởi động nhanh, nhưng chậm hơn về tổng thể, vì một đoạn mã được gọi 1000 lần, nó sẽ bị dịch 1000 lần.
          * **ii. Biên dịch JIT (Just-In-Time):** JVM sẽ theo dõi xem những phần mã nào (phương thức nào) được gọi thường xuyên nhất ("hotspot"). JIT dịch toàn bộ đoạn bytecode đó một lần duy nhất sang mã máy gốc (native machine code). Lần tới khi gọi lại "hotspot" này thì sẽ không phải biên dịch nữa.

## Một số thuật ngữ

  * **JDK (Java Development Kit):** Bộ công cụ dành cho lập trình viên. Nó chứa mọi thứ, bao gồm JRE + trình biên dịch (`javac`).
  * **JRE (Java Runtime Environment):** Bộ môi trường chỉ để *chạy* ứng dụng Java. Nó chứa JVM + các thư viện Java.
  * **JVM (Java Virtual Machine):** "Trái tim" của JRE. Đây là chương trình phần mềm thực tế đọc bytecode (`.class`) và thực thi nó.

-----

## Cấu trúc cơ bản của Java

```java
public class TenChuongTrinh {
    public static void main(String[] args) {
        // Code được viết ở đây
        // Đây là nơi chương trình bắt đầu thực thi
    }
}
```

Trong đó:

  * **`public class HelloWorld`**
      * `class`: Từ khóa dùng để khai báo một lớp (class).
      * `HelloWorld`: Tên lớp (phải trùng với tên file, ở đây là `HelloWorld.java`).
      * `public`: Cho phép lớp này được truy cập từ mọi nơi.
  * **`public static void main(String[] args)`:** Hàm chính— nơi chương trình bắt đầu chạy.
      * `public`: Cho phép JVM truy cập hàm này.
      * `static`: JVM có thể gọi hàm này mà không cần tạo đối tượng.
      * `void`: Hàm này không trả về giá trị.
      * `String[] args`: Dùng để nhận tham số dòng lệnh (nếu có).
  * **`System.out.println("Hello, world!");`**
      * `System.out` là đối tượng xuất chuẩn (console).
      * `println` là hàm in ra một dòng văn bản, sau đó xuống dòng.

-----

## Package

Package trong Java là một "thư mục" để tổ chức các lớp (classes). Khi dự án của chúng ta lớn lên, ta sẽ có hàng trăm, thậm chí hàng nghìn lớp. Package giúp ta nhóm chúng lại một cách logic.

  * **Ví dụ:**
      * Tất cả các lớp xử lý giao diện người dùng có thể nằm trong package `com.mygame.ui`.
      * Tất cả các lớp xử lý logic game có thể nằm trong `com.mygame.logic`.
      * Tất cả các lớp xử lý mạng có thể nằm trong `com.mygame.network`.

Package cũng hỗ trợ khá tốt trong vấn đề trùng lặp tên. Ví dụ như `Date` dùng để lưu ngày. Đó có thể là `deadline.Date` hoặc `birthday.Date`.

### Khai báo Package

```java
// Tệp này nằm trong thư mục: com/mycompany/myapp
package com.mycompany.myapp;

// Lớp này giờ thuộc về package 'com.mycompany.myapp'
public class MyClass {
    // ...
}
```

### Import Package

```java
package com.mycompany.anotherapp;

// "Dùng lớp 'Scanner' từ package 'java.util'"
import java.util.Scanner; 

// "Dùng lớp 'MyClass' từ package 'com.mycompany.myapp'"
import com.mycompany.myapp.MyClass;

public class MainApp {
    public static void main(String[] args) {
        // Bây giờ ta có thể dùng 'Scanner' và 'MyClass'
        Scanner scanner = new Scanner(System.in);
        MyClass obj = new MyClass();
    }
}
```

-----

## Cú pháp (Syntax)

### Khai báo biến

Khai báo: `kieudulieu ten_bien;`

  * **Kiểu số nguyên:** `byte`, `short`, `int`, `long`.
  * **Kiểu số thực:** `float`, `double`.
  * **Kiểu ký tự:** `char`
  * **Kiểu logic:** `boolean`

### Vòng lặp `for`

Cấu trúc của nó gồm 3 phần, phân cách bởi dấu chấm phẩy `;`:

1.  **Khởi tạo (Initialization):** Một biểu thức được thực thi *một lần duy nhất* khi vòng lặp bắt đầu (ví dụ: `int i = 0`).
2.  **Điều kiện (Condition):** Một biểu thức logic được kiểm tra *trước* mỗi lần lặp. Nếu là `true`, vòng lặp tiếp tục; nếu là `false`, vòng lặp kết thúc (ví dụ: `i < 5`).
3.  **Cập nhật (Update):** Một biểu thức được thực thi *sau* mỗi lần lặp (ví dụ: `i++` để tăng `i` lên 1).

**Code:**

```java
public class ForLoop {
    public static void main(String[] args) {
        for (int i = 1; i <= 5; i++) {
            System.out.println("Số: " + i);
        }
    }
}
```

### Vòng lặp `while`

Vòng lặp `while` (trong khi) được sử dụng khi ta **không biết trước số lần lặp**, nhưng biết **điều kiện để dừng lại**. Nó chỉ kiểm tra một điều kiện duy nhất. Chừng nào điều kiện còn `true`, khối mã sẽ còn được thực thi.

**Lưu ý:** Vòng lặp `while` kiểm tra điều kiện *trước* khi chạy. Nếu điều kiện là `false` ngay từ đầu, khối mã sẽ *không bao giờ* được thực thi.

```java
public class WhileLoop {
    public static void main(String[] args) {
        int demNguoc = 3;

        while (demNguoc > 0) {
            System.out.println(demNguoc);
            demNguoc--; // Cập nhật biến điều kiện
        }
        System.out.println("Bắt đầu!");
    }
}
```

### Vòng lặp `do-while`

Vòng lặp `do-while` tương tự như `while`, nhưng có một khác biệt lớn: nó luôn **thực thi khối mã ít nhất một lần**, sau đó mới kiểm tra điều kiện. Nó chạy mã *trước*, rồi mới kiểm tra điều kiện *sau*. Điều này hữu ích khi ta muốn hành động được thực hiện ít nhất một lần (ví dụ: hiển thị menu cho người dùng).

```java
public class DoWhileLoop {
    public static void main(String[] args) {
        int x = 10;

        // Mã sẽ chạy 1 lần, in ra "x = 10"
        // Sau đó nhận ra điều kiện (10 < 5) là sai => không chạy nữa
        do {
            System.out.println("Giá trị của x là: " + x);
            x++;
        } while (x < 5);                
    }
}
```

### Từ khóa `break` và `continue`

Giúp kiểm soát vòng lặp.

  * **`break`**: Thoát khỏi vòng lặp *ngay lập tức*, bỏ qua tất cả các lần lặp còn lại.
  * **`continue`**: Bỏ qua phần còn lại của lần lặp *hiện tại* và nhảy ngay đến lần lặp tiếp theo.

-----

## Câu lệnh rẽ nhánh

Câu lệnh rẽ nhánh (branching statements) cho phép chương trình đưa ra quyết định dựa trên một điều kiện là đúng (`true`) hay sai (`false`) để chương trình sẽ quyết định chạy khối mã nào tiếp theo. 


Trong Java, có hai câu lệnh rẽ nhánh chính: `if` và `switch`.

### 1\. Lệnh `if` (Nếu... thì...)

Đây là câu lệnh rẽ nhánh cơ bản và phổ biến nhất.

**a. `if` đơn**
Chỉ thực thi mã nếu điều kiện là `true`.
*Cú pháp:*

```java
if (điều_kiện) {
    // Khối mã này sẽ chạy
    // nếu 'điều_kiện' là true
}
```

*Ví dụ:*

```java
int tuoi = 20;
if (tuoi >= 18) {
    System.out.println("Bạn đã đủ tuổi trưởng thành.");
}
```

**b. `if-else`**
Cung cấp một con đường thứ hai. Nếu điều kiện là `true`, chạy khối `if`. Nếu là `false`, chạy khối `else`.
*Cú pháp:*

```java
if (điều_kiện) {
    // Chạy khối này nếu 'điều_kiện' là true
} else {
    // Chạy khối này nếu 'điều_kiện' là false
}
```

*Ví dụ:*

```java
int so = 7;
if (so % 2 == 0) {
    System.out.println(so + " là số chẵn.");
} else {
    System.out.println(so + " là số lẻ.");
}
```

**c. `if-else if-else` (Thang `if`) **
Dùng để kiểm tra nhiều điều kiện liên tiếp. Nó sẽ kiểm tra từ trên xuống dưới và thực thi khối mã đầu tiên có điều kiện `true`.
*Cú pháp:*

```java
if (điều_kiện_1) {
    // Chạy nếu 'điều_kiện_1' là true
} else if (điều_kiện_2) {
    // Chạy nếu 'điều_kiện_1' là false
    // VÀ 'điều_kiện_2' là true
} else {
    // Chạy nếu tất cả các điều kiện trên
    // đều là false
}
```

*Ví dụ:*

```java
int diem = 85;

if (diem >= 90) {
    System.out.println("Xếp loại: Xuất sắc");
} else if (diem >= 80) {
    System.out.println("Xếp loại: Giỏi"); // Sẽ in ra dòng này
} else if (diem >= 65) {
    System.out.println("Xếp loại: Khá");
} else {
    System.out.println("Xếp loại: Trung bình");
}
```

### 2\. Lệnh `switch` (Chuyển đổi)

Lệnh `switch` là một giải pháp thay thế gọn gàng cho một thang `if-else if-else` dài, khi bạn chỉ cần **so sánh một biến với nhiều giá trị cụ thể**. Nó kiểm tra một biến và "chuyển" đến `case` (trường hợp) khớp với giá trị của biến đó.

*Cú pháp:*

```java
switch (biến_cần_kiểm_tra) {
    case gia_tri_1:
        // Mã thực thi nếu biến == gia_tri_1
        break; // Rất quan trọng!
    
    case gia_tri_2:
        // Mã thực thi nếu biến == gia_tri_2
        break;
        
    // ... thêm các case khác ...
        
    default:
        // Mã thực thi nếu không
        // khớp với bất kỳ case nào ở trên
}
```

**Điểm mấu chốt của `switch`:**

  * **`break`**: Từ khóa `break` là bắt buộc ở cuối mỗi `case` (trừ khi ta cố ý muốn "rơi" xuống `case` tiếp theo). Nếu không có `break`, chương trình sẽ tiếp tục chạy mã của các `case` bên dưới nó.
  * **`default`**: Giống như `else`. Nó là tùy chọn và sẽ chạy nếu không có `case` nào khớp.

*Ví dụ:*

```java
int ngayTrongTuan = 4; // 1 = Chủ Nhật, 2 = Thứ Hai, ...
String tenNgay;

switch (ngayTrongTuan) {
    case 1:
        tenNgay = "Chủ Nhật";
        break;
    case 2:
        tenNgay = "Thứ Hai";
        break;
    case 3:
        tenNgay = "Thứ Ba";
        break;
    case 4:
        tenNgay = "Thứ Tư";
        break; // Sẽ khớp ở đây
    case 5:
        tenNgay = "Thứ Năm";
        break;
    case 6:
        tenNgay = "Thứ Sáu";
        break;
    case 7:
        tenNgay = "Thứ Bảy";
        break;
    default:
        tenNgay = "Ngày không hợp lệ";
}

System.out.println("Hôm nay là: " + tenNgay); // In ra: Hôm nay là: Thứ Tư
```

### 3\. Toán tử ba ngôi (Ternary Operator)

Đây không phải là một *câu lệnh*, mà là một *toán tử*. Nó là cách viết tắt siêu gọn cho một câu lệnh `if-else` đơn giản dùng để gán giá trị.

*Cú pháp:*

```java
biến = (điều_kiện) ? gia_tri_neu_true : gia_tri_neu_false;
```

*Ví dụ:*
Code dưới đây

```java
int so = 10;
String ketQua;
if (so % 2 == 0) {
    ketQua = "Số chẵn";
} else {
    ketQua = "Số lẻ";
}
```

Có thể được viết gọn lại thành 1 dòng:

```java
int so = 10;
String ketQua = (so % 2 == 0) ? "Số chẵn" : "Số lẻ";
// ketQua bây giờ sẽ là "Số chẵn"
```

-----

## Mảng (Array)

Mảng (Array) trong Java là một **cấu trúc dữ liệu cơ bản** giống như một **dãy tủ có ngăn kéo**. Mảng cho phép ta lưu trữ nhiều giá trị trong **một biến duy nhất**. Tất cả các phần tử có **cùng một kiểu dữ liệu** (ví dụ, tất cả đều là số `int`, hoặc tất cả đều là chuỗi `String`).

**Đặc điểm chính:**

  * **Kích thước cố định (Fixed-Size):** Khi khởi tạo mảng, cần phải quyết định nó có bao nhiêu ngăn. Kích thước này không thể thay đổi sau đó.
  * **Cùng kiểu dữ liệu (Same Data Type):** Một mảng `int` chỉ có thể chứa `int`.
  * **Truy cập bằng chỉ số (Index-Based):** Truy cập từng phần tử bằng "số thứ tự" của nó, gọi là *chỉ số* (index).

### 1\. Khai báo và Khởi tạo Mảng

Có hai cách chính để tạo một mảng:

**Cách 1: Khai báo kích thước trước (Phổ biến)**
Cú pháp: kiểu_dữ_liệu[] tên_biến = new kiểu_dữ_liệu[kích_thước];

```java


// Tạo một mảng tên 'diemSo' để chứa 5 số nguyên
int[] diemSo = new int[5];

// Tạo một mảng tên 'tenHocSinh' để chứa 10 chuỗi
String[] tenHocSinh = new String[10];
```

Khi bạn tạo mảng theo cách này, Java sẽ tự động gán **giá trị mặc định** cho các phần tử:

  * `int`, `double`...: `0` (hoặc `0.0`)
  * `boolean`: `false`
  * `String` (và các đối tượng khác): `null`

**Cách 2: Khai báo và gán giá trị ngay (Cú pháp ngắn)**
Cung cấp các giá trị ban đầu, và Java sẽ tự hiểu kích thước.

```java
// Cú pháp: kiểu_dữ_liệu[] tên_biến = {giá_trị_1, giá_trị_2, ...};

// Tạo một mảng số nguyên
int[] numbers = {10, 20, 30, 40, 50}; // Java tự hiểu mảng này có kích thước 5

// Tạo một mảng chuỗi
String[] traiCay = {"Táo", "Cam", "Chuối"}; // Kích thước là 3
```

### 2\. Truy cập các phần tử (Quan trọng: Chỉ số từ 0)

Đây là điểm quan trọng nhất: Mảng trong Java (và hầu hết các ngôn ngữ) **bắt đầu đếm từ 0**, không phải từ 1.

  * Phần tử **đầu tiên** có chỉ số (index) là `0`.
  * Phần tử **cuối cùng** có chỉ số là `kích_thước - 1`.

Ví dụ: `traiCay` có 3 phần tử:

  * `traiCay[0]` là "Táo"
  * `traiCay[1]` là "Cam"
  * `traiCay[2]` là "Chuối"

**Gán giá trị (Write)**
Dùng `[]` kết hơp với chỉ số mình muốn gán.

```java
int[] diemSo = new int[3];

diemSo[0] = 10;   // Gán 10 cho phần tử đầu tiên
diemSo[1] = 8;
diemSo[2] = 5;
```

**Lấy giá trị (Read)**
Sử dụng `[]` kèm chỉ số để xem bên trong "ngăn tủ" có gì.

```java
System.out.println(diemSo[0]);  // Sẽ in ra 10
System.out.println(traiCay[1]); // Sẽ in ra "Cam"
```

### 3\. Lấy kích thước mảng (`.length`)

Để biết mảng có bao nhiêu phần tử, dùng thuộc tính `.length` (lưu ý: không có dấu `()` như ở C++).

```java
String[] traiCay = {"Táo", "Cam", "Chuối"};
System.out.println(traiCay.length); // Sẽ in ra 3

int[] diemSo = new int[5];
System.out.println(diemSo.length); // Sẽ in ra 5
```

### 4\. Duyệt Mảng (Dùng vòng lặp)

Cách phổ biến nhất để làm việc với mảng là dùng vòng lặp để đi qua từng phần tử.

**Cách 1: Dùng vòng lặp** `for` 
Cách này cho phép ta kiểm soát cả **chỉ số (index)** và **giá trị**.

```java
String[] traiCay = {"Táo", "Cam", "Chuối"};

// Bắt đầu từ i = 0 (phần tử đầu tiên)
// Dừng lại khi i = length (vì chỉ số cuối là length - 1)
for (int i = 0; i < traiCay.length; i++) {
    System.out.println("Phần tử tại chỉ số " + i + " là: " + traiCay[i]);
}
```

*Kết quả:*

```
Phần tử tại chỉ số 0 là: Táo
Phần tử tại chỉ số 1 là: Cam
Phần tử tại chỉ số 2 là: Chuối
```

**Cách 2: Dùng vòng lặp** `for-each` 
Dùng khi chỉ quan tâm đến **giá trị**, duyệt mà **không cần biết chỉ số**.

```java
int[] numbers = {10, 20, 30};

// Đọc là: "Với mỗi 'so' (kiểu int) trong mảng 'numbers'..."
for (int so : numbers) {
    System.out.println(so);
}
```

*Kết quả:*

```
10
20
30
```

### 5\. Lỗi thường gặp

**`ArrayIndexOutOfBoundsException`** 
Đây là lỗi xảy ra khi cố gắng truy cập một chỉ số không tồn tại.

```java
String[] traiCay = {"Táo", "Cam", "Chuối"}; // Kích thước 3, chỉ số hợp lệ: 0, 1, 2

// Dòng này sẽ gây LỖI
System.out.println(traiCay[3]); // Lỗi! Không có chỉ số 3.

// Dòng này cũng LỖI
System.out.println(traiCay[-1]); // Lỗi! Chỉ số không thể là số âm.
```

-----

## Tổng quan về Class và Object

Đây là khái niệm **trung tâm và quan trọng nhất** của Lập trình Hướng đối tượng (OOP). Cách dễ hiểu nhất là dùng một phép so sánh:

  * **`Class` (Lớp)**: Là một **bản thiết kế** (blueprint) hoặc một **khuôn mẫu** (template).
  * **`Object` (Đối tượng)**: Là một **ngôi nhà cụ thể** được xây dựng từ bản thiết kế đó.

Từ *một* bản thiết kế **(Class)**, ta có thể xây dựng *nhiều* ngôi nhà **(Objects)** từ bản thiết kế đó. Mỗi ngôi nhà là một thực thể riêng biệt, nhưng tất cả đều tuân theo cùng một bản thiết kế.

### 1\. `Class` (Lớp) là gì?

**`Class` là một bản thiết kế mô tả các thuộc tính và hành vi mà một loại đối tượng sẽ có.** Nó là một khái niệm trừu tượng.

Bản thiết kế `NgoiNha` sẽ định nghĩa rằng:

1.  **Thuộc tính (Attributes):** Ngôi nhà sẽ *có* những gì? (Đây là các **biến**)
      * `int soPhong;` (số phòng)
      * `String mauSon;` (màu sơn)
      * `int soTang;` (số tầng)
2.  **Phương thức (Methods):** Ngôi nhà có thể *làm* được gì? (Đây là các **hàm**)
      * `void moCua() { ... }`
      * `void batDen() { ... }`

Khi viết một `Class` trong Java, ta không tạo ra bất cứ thứ gì cụ thể; ta chỉ đang *thiết kế* nó.

**Ví dụ code `Class`:**
Đây là "bản thiết kế" cho một chiếc xe hơi. Tệp này sẽ được lưu là `XeHoi.java`.

```java
public class XeHoi {
    // 1. Thuộc tính (biến)
    String thuongHieu;
    String mauSac;
    int namSanXuat;

    // 2. Phương thức (hàm)
    void chay() {
        System.out.println("Xe " + thuongHieu + " đang chạy... Vroom vroom!");
    }

    void phanh() {
        System.out.println("Xe đang phanh...");
    }
}
```

### 2\. `Object` (Đối tượng) là gì?

**`Object` là một thể hiện (instance) cụ thể của một `Class`.** Đây là một thực thể có thật trong bộ nhớ máy tính mà ta có thể tương tác.

Quay lại ví dụ:

  * Bản thiết kế `NgoiNha` là **Class**.
  * Ngôi nhà của ta (màu xanh, 3 tầng) là một **Object**.
  * Ngôi nhà của hàng xóm (màu vàng, 2 tầng) là một **Object** khác.

Cả hai ngôi nhà đều được xây từ cùng một bản thiết kế, nhưng chúng là hai thực thể riêng biệt với các *trạng thái* (thuộc tính) khác nhau. Trong Java, từ khóa **`new`** được sử dụng để "xây dựng" một đối tượng từ bản thiết kế (Class). Quá trình này gọi là **khởi tạo (instantiation)**.

**Ví dụ code `Object`:**
Bây giờ, chúng ta sẽ vào phương thức `main` (ở một tệp khác) để *sử dụng* bản thiết kế `XeHoi` ở trên.

```java
public class TiemSuaXe {
    public static void main(String[] args) {
        
        // Dùng từ khóa 'new' để tạo 2 đối tượng từ Class 'XeHoi'
        // 'xeCuaToi' là một Object (một thể hiện)
        XeHoi xeCuaToi = new XeHoi(); 
        
        // 'xeCuaBan' là một Object khác
        XeHoi xeCuaBan = new XeHoi();

        // -----------------------------------------------------

        // Mỗi đối tượng có thuộc tính riêng
        xeCuaToi.thuongHieu = "Vinfast";
        xeCuaToi.mauSac = "Đỏ";

        xeCuaBan.thuongHieu = "Toyota";
        xeCuaBan.mauSac = "Trắng";

        // -----------------------------------------------------

        // Gọi phương thức từ mỗi đối tượng
        
        // In ra: "Xe Vinfast đang chạy... Vroom vroom!"
        xeCuaToi.chay(); 

        // In ra: "Xe Toyota đang chạy... Vroom vroom!"
        xeCuaBan.chay();
    }
}
```

### Bảng so sánh

| Khái niệm      | `Class` (Lớp)                             | `Object` (Đối tượng)                            |
| :------------- | :---------------------------------------- | :---------------------------------------------- |
| **Định nghĩa** | Là một **bản thiết kế** hoặc khuôn mẫu.   | Là một **thể hiện** (instance) của một Class.   |
| **Bản chất**   | Trừu tượng, logic.                        | Cụ thể, vật lý (tồn tại trong bộ nhớ).          |
| **Ví dụ**      | Bản thiết kế `XeHoi`.                     | Chiếc `XeHoi` màu đỏ, thương hiệu Vinfast.      |
| **Cách tạo**   | Được định nghĩa 1 lần (viết tệp `.java`). | Được khởi tạo nhiều lần bằng từ khóa **`new`**. |
| **Từ khóa**    | `class`                                   | `new`                                           |

-----

## Các từ khóa OOP quan trọng

Đây là những khái niệm then chốt trong Lập trình Hướng đối tượng (OOP) của Java. Chúng dùng để định nghĩa và kiểm soát hành vi của các `Class` và `Object`.

### 1\. Từ khóa `this`

Từ khóa **`this`** là một tham chiếu trỏ đến **đối tượng hiện tại** (đối tượng đang gọi phương thức). Nó được dùng phổ biến nhất để **phân biệt biến của lớp (instance variable) và tham số của phương thức (parameter)** khi chúng có tên giống hệt nhau.

Hãy tưởng tượng bạn (đối tượng) nói "đưa cho tôi `this.ten`", có nghĩa là "đưa cho tôi cái `ten` *của tôi*", chứ không phải cái `ten` nào khác.

*Ví dụ:*
Trong một hàm dựng (constructor), ta thường thấy:

```java
public class HocSinh {
    String ten; // Biến của lớp (instance variable)

    // 'ten' ở đây là tham số (parameter)
    public HocSinh(String ten) { 
        // 'this.ten' là biến của lớp
        // '=' 'ten' là tham số truyền vào
        this.ten = ten; 
    }
}
```

  * `this.ten = ten;` có nghĩa là: "Lấy giá trị từ tham số `ten` và gán nó vào biến `ten` *của đối tượng này*".

### 2\. `Constructor` (Hàm dựng)

**Constructor** (hàm dựng) là một **phương thức đặc biệt** được tự động gọi khi khởi tạo một đối tượng mới (instance) từ một `Class` bằng từ khóa `new`. Nhiệm vụ chính của nó là **khởi tạo** các thuộc tính (biến) cho đối tượng.

**Đặc điểm nhận dạng:**

1.  Nó có tên **giống hệt** tên của `Class`.
2.  Nó **không có kiểu trả về** (thậm chí không có `void`).

<!-- end list -->

```java
public class XeHoi {
    String mauSac;
    int soChoNgoi;

    // Đây là một Constructor
    // Nó được gọi khi ta viết: new XeHoi("Đỏ", 4)
    public XeHoi(String mau, int soCho) {
        System.out.println("Đang tạo một xe hơi mới...");
        this.mauSac = mau;
        this.soChoNgoi = soCho;
    }
}

// Cách sử dụng:
XeHoi xeVinfast = new XeHoi("Đỏ", 4); // "Đang tạo một xe hơi mới..." sẽ in ra
```

### 3\. `Access Modifier` (Bổ từ truy cập)

Đây là các từ khóa dùng để **thiết lập quyền truy cập (mức độ hiển thị)** cho các `Class`, thuộc tính (biến), và phương thức. Chúng thực thi *tính đóng gói* (Encapsulation).

Có 4 loại chính:

1.  **`public` (Công khai):** 
      * Ai cũng thấy. Có thể được truy cập từ bất kỳ `Class` nào, bất kỳ `package` nào.
      * Đây là mức độ "mở" nhất.
2.  **`protected` (Được bảo vệ):** 
      * "Gia đình và con cái".
      * Có thể được truy cập bởi các `Class` trong **cùng một `package`** VÀ bởi các **`Class` con** (subclasses) ngay cả khi chúng ở khác `package`.
3.  **`default` (Mặc định - không ghi gì):** 
      * "Chỉ trong gia đình".
      * Chỉ có thể được truy cập bởi các `Class` trong **cùng một `package`**.
4.  **`private` (Riêng tư):** 
      * "Chỉ mình tôi".
      * Chỉ có thể được truy cập **bên trong chính `Class`** đó.
      * Đây là mức độ "đóng" nhất.

**Quy tắc chung:** Luôn cố gắng đặt các thuộc tính (biến) là `private` và chỉ cho phép truy cập chúng qua các phương thức `public` (chính là Getter và Setter).

### 4\. `Getter` (Phương thức Lấy)

**Getter** là một phương thức `public` dùng để **lấy (đọc) giá trị** của một thuộc tính `private`. Theo quy ước, tên của nó bắt đầu bằng `get` theo sau là tên thuộc tính (viết hoa chữ cái đầu).

```java
public class NguoiDung {
    private String tenNguoiDung;

    // Getter cho 'tenNguoiDung'
    public String getTenNguoiDung() {
        return this.tenNguoiDung;
    }
}
```

### 5\. `Setter` (Phương thức Đặt)

**Setter** là một phương thức `public` (thường là `void`) dùng để **thiết lập (ghi/thay đổi) giá trị** cho một thuộc tính `private`. Nó cho phép ta thêm logic kiểm tra dữ liệu đầu vào. Theo quy ước, tên của nó bắt đầu bằng `set` theo sau là tên thuộc tính.

```java
public class NguoiDung {
    private String tenNguoiDung;
    private int tuoi;

    // Setter cho 'tenNguoiDung'
    public void setTenNguoiDung(String tenMoi) {
        this.tenNguoiDung = tenMoi;
    }

    // Setter với logic kiểm tra
    public void setTuoi(int tuoiMoi) {
        if (tuoiMoi > 0) { // Kiểm tra tính hợp lệ
            this.tuoi = tuoiMoi;
        } else {
            System.out.println("Tuổi không hợp lệ!");
        }
    }
}
```

**Getter và Setter** là nền tảng của **tính đóng gói (Encapsulation)**, giúp ta bảo vệ dữ liệu của mình.

### 6\. Từ khóa `static` (Tĩnh)

Từ khóa **`static`** dùng để tạo ra các biến hoặc phương thức **thuộc về `Class`**, chứ không thuộc về bất kỳ `Object` (thể hiện) cụ thể nào.

Hãy nghĩ `static` là "đồ dùng chung" của cả lớp học (Class), còn các biến không-`static` là "đồ dùng riêng" của mỗi học sinh (Object).

**Biến `static` (Static Variable):**
Là một biến "chung". Tất cả các đối tượng tạo ra từ `Class` đó đều chia sẻ **chung một bản sao** của biến này.

*Ví dụ:* Đếm số lượng đối tượng `HocSinh` đã được tạo.

```java
public class HocSinh {
    String ten; // Đồ dùng riêng (mỗi học sinh có tên riêng)
    static int soLuongHocSinh = 0; // Đồ dùng chung (cả lớp chung 1 sĩ số)

    public HocSinh(String ten) {
        this.ten = ten;
        soLuongHocSinh++; // Tăng biến static
    }
}

// Cách sử dụng:
HocSinh an = new HocSinh("An");
HocSinh binh = new HocSinh("Bình");

// Truy cập biến static qua TÊN LỚP
System.out.println(HocSinh.soLuongHocSinh); // In ra 2
```

**Phương thức `static` (Static Method):**
Là một phương thức "chung" mà ta có thể gọi **trực tiếp từ `Class`** mà không cần tạo đối tượng.

  * Phương thức `static` **chỉ** có thể truy cập các thành viên `static` khác.
  * Ví dụ kinh điển là `Math.sqrt()` (lấy căn bậc hai). Ta không cần `new Math()` để dùng nó.

<!-- end list -->

```java
public class TinhToan {
    static final double PI = 3.14; // Biến static thường là hằng số

    // Phương thức static
    public static int cong(int a, int b) {
        return a + b;
    }
}

// Cách sử dụng:
int ketQua = TinhToan.cong(5, 10); // Gọi thẳng từ Class
System.out.println(ketQua); // In ra 15
```